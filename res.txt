    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

factory
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

factory
    address public immutable override factory;
factory
    constructor address _factory  address _WETH9  
factory
        factory = _factory;
factory
    function computeAddress address factory  PoolKey memory key internal pure returns  address pool  
factory
                        factory 
factory
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

factory
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
factory
    function verifyCallback address factory  PoolAddress PoolKey memory poolKey
        internal
        view
        returns  IUniswapV3Pool pool
     

factory
        pool = IUniswapV3Pool PoolAddress computeAddress factory  poolKey;
factory
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
factory
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
factory
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
factory
    constructor address _factory  address _WETH9  
_factory
        factory = _factory;
_factory
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
_factory
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

WETH9
    address public immutable override WETH9;
WETH9
    constructor address _factory  address _WETH9  
WETH9
        WETH9 = _WETH9;
WETH9
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

WETH9
        require msg sender == WETH9  'Not WETH9';
WETH9
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
WETH9
        uint256 balanceWETH9 = IWETH9 WETH9 balanceOf address this;
WETH9
        require balanceWETH9 >= amountMinimum  'Insufficient WETH9';
WETH9
        if  balanceWETH9 > 0  
WETH9
            IWETH9 WETH9 withdraw balanceWETH9;
WETH9
            TransferHelper safeTransferETH recipient  balanceWETH9;
WETH9
        if  token == WETH9 && address this balance >= value  
WETH9
            IWETH9 WETH9 deposit value: value ;    wrap only what is needed to pay
WETH9
            IWETH9 WETH9 transfer recipient  value;
WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

WETH9
        uint256 balanceWETH9 = IWETH9 WETH9 balanceOf address this;
WETH9
        require balanceWETH9 >= amountMinimum  'Insufficient WETH9';
WETH9
        if  balanceWETH9 > 0  
WETH9
            IWETH9 WETH9 withdraw balanceWETH9;
WETH9
            uint256 feeAmount = balanceWETH9 mul feeBips   10_000;
WETH9
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
WETH9
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
WETH9
    constructor address _factory  address _WETH9  
_WETH9
        WETH9 = _WETH9;
_WETH9
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
_WETH9
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

token
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

token
        address tokenIn;
token
        address tokenOut;
token
        address tokenIn;
token
        address tokenOut;
token
       @dev Returns the amount of tokens in existence 
token
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

token
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

token
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

token
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

token
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

token
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
token
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
token
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
token
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            TransferHelper safeTransfer token  recipient  balanceToken;
token
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

token
        if  token == WETH9 && address this balance >= value  
token
            TransferHelper safeTransfer token  recipient  value;
token
            TransferHelper safeTransferFrom token  payer  recipient  value;
token
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

token
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
token
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
token
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
token
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
token
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
token
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
token
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < type uint256 max
token
            selfPermitAllowed token  nonce  expiry  v  r  s;
token
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

token
        tokenA = path toAddress 0;
token
        tokenB = path toAddress NEXT_OFFSET;
token
        address token0;
token
        address token1;
token
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

token
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
token
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
token
        require key token0 < key token1;
token
                        keccak256 abi encode key token0  key token1  key fee 
token
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

token
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

token
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
token
                ?  tokenIn < tokenOut  uint256 amount0Delta
token
                :  tokenOut < tokenIn  uint256 amount1Delta;
token
            pay tokenIn  data payer  msg sender  amountToPay;
token
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
token
                pay tokenIn  data payer  msg sender  amountToPay;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
token
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
token
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

from
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

from
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

from
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

from
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
from
       - `v`  `r` and `s` must be a valid `secp256k1` signature from `owner`
from
       prevents a signature from being used multiple times 
from
    function toUint160 uint256 y internal pure returns  uint160 z  
to
    function toInt128 int256 y internal pure returns  int128 z  
to
    function toInt256 uint256 y internal pure returns  int256 z  
to
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

to
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

to
    function setFeeProtocol uint8 feeProtocol0  uint8 feeProtocol1 external;







    function collectProtocol 
        address recipient 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;





interface IUniswapV3PoolEvents  

to
    event SetFeeProtocol uint8 feeProtocol0Old  uint8 feeProtocol1Old  uint8 feeProtocol0New  uint8 feeProtocol1New;
to
    event CollectProtocol address indexed sender  address indexed recipient  uint128 amount0  uint128 amount1;
to
        address tokenIn;
to
        address tokenOut;
to
        address tokenIn;
to
        address tokenOut;
to
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

to
    address public immutable override factory;
to
    constructor address _factory  address _WETH9  
to
        factory = _factory;
to
        require _blockTimestamp  <= deadline  'Transaction too old';
to
       @dev Returns the amount of tokens in existence 
to
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

to
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

to
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

to
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

to
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

to
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

to
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

to
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
to
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

to
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
to
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

to
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
to
    function safeTransferETH address to  uint256 value internal  
to
         bool success   = to call value: value new bytes 0;
to
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

to
        uint256 balanceToken = IERC20 token balanceOf address this;
to
        require balanceToken >= amountMinimum  'Insufficient token';
to
            TransferHelper safeTransfer token  recipient  balanceToken;
to
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

to
        if  token == WETH9 && address this balance >= value  
to
            IWETH9 WETH9 deposit value: value ;    wrap only what is needed to pay
to
            TransferHelper safeTransfer token  recipient  value;
to
            TransferHelper safeTransferFrom token  payer  recipient  value;
to
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

to
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

to
        uint256 balanceToken = IERC20 token balanceOf address this;
to
        require balanceToken >= amountMinimum  'Insufficient token';
to
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
to
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
to
   @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures  as defined in
to
   Adds the  permit method  which can be used to change an account's ERC20 allowance  see  IERC20-allowance by
to
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
to
   need to send a transaction  and thus is not required to hold Ether at all 
to
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
to
       IMPORTANT: The same issues  IERC20-approve has related to transaction
to
       Every successful call to  permit increases ``owner``'s nonce by one  This
to
    function nonces address owner external view returns  uint256;

       
       @dev Returns the domain separator used in the encoding of the signature for  permit  as defined by  EIP712 

to
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

to
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

to
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
to
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

to
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
to
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

to
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
to
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

to
        if  IERC20 token allowance msg sender  address this < type uint256 max
to
            selfPermitAllowed token  nonce  expiry  v  r  s;
to
                        mstore mc  mload cc
to
                    mstore tempBytes  _length
to
                    mstore 0x40  and add mc  31  not 31
to
                    mstore tempBytes  0
to
                    mstore 0x40  add tempBytes  0x20
to
    function toAddress bytes memory _bytes  uint256 _start internal pure returns  address  
to
        require _start + 20 >= _start  'toAddress_overflow';
to
        require _bytes length >= _start + 20  'toAddress_outOfBounds';
to
    function toUint24 bytes memory _bytes  uint256 _start internal pure returns  uint24  
to
        require _start + 3 >= _start  'toUint24_overflow';
to
        require _bytes length >= _start + 3  'toUint24_outOfBounds';
to
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

to
        tokenA = path toAddress 0;
to
        fee = path toUint24 ADDR_SIZE;
to
        tokenB = path toAddress NEXT_OFFSET;
to
        address token0;
to
        address token1;
to
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

to
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
to
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
to
    function computeAddress address factory  PoolKey memory key internal pure returns  address pool  
to
        require key token0 < key token1;
to
                        factory 
to
                        keccak256 abi encode key token0  key token1  key fee 
to
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

to
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
to
    function verifyCallback address factory  PoolAddress PoolKey memory poolKey
        internal
        view
        returns  IUniswapV3Pool pool
     

to
        pool = IUniswapV3Pool PoolAddress computeAddress factory  poolKey;
to
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
to
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

to
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
to
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
to
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
to
                ?  tokenIn < tokenOut  uint256 amount0Delta
to
                :  tokenOut < tokenIn  uint256 amount1Delta;
to
            pay tokenIn  data payer  msg sender  amountToPay;
to
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
to
                pay tokenIn  data payer  msg sender  amountToPay;
to
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
to
        bool zeroForOne = tokenIn < tokenOut;
to
            getPool tokenIn  tokenOut  fee swap 
to
                amountIn toInt256  
to
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
to
                hasMultiplePools ? address this : params recipient     for intermediate swaps  this contract custodies
to
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
to
        bool zeroForOne = tokenIn < tokenOut;
to
            getPool tokenIn  tokenOut  fee swap 
to
                -amountOut toInt256  
to
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
to
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

token
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

token
        address tokenIn;
token
        address tokenOut;
token
        address tokenIn;
token
        address tokenOut;
token
       @dev Returns the amount of tokens in existence 
token
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

token
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

token
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

token
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

token
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

token
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
token
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
token
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
token
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            TransferHelper safeTransfer token  recipient  balanceToken;
token
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

token
        if  token == WETH9 && address this balance >= value  
token
            TransferHelper safeTransfer token  recipient  value;
token
            TransferHelper safeTransferFrom token  payer  recipient  value;
token
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

token
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
token
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
token
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
token
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
token
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
token
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
token
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < type uint256 max
token
            selfPermitAllowed token  nonce  expiry  v  r  s;
token
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

token
        tokenA = path toAddress 0;
token
        tokenB = path toAddress NEXT_OFFSET;
token
        address token0;
token
        address token1;
token
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

token
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
token
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
token
        require key token0 < key token1;
token
                        keccak256 abi encode key token0  key token1  key fee 
token
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

token
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

token
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
token
                ?  tokenIn < tokenOut  uint256 amount0Delta
token
                :  tokenOut < tokenIn  uint256 amount1Delta;
token
            pay tokenIn  data payer  msg sender  amountToPay;
token
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
token
                pay tokenIn  data payer  msg sender  amountToPay;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
token
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
token
    function toUint160 uint256 y internal pure returns  uint160 z  
to
    function toInt128 int256 y internal pure returns  int128 z  
to
    function toInt256 uint256 y internal pure returns  int256 z  
to
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

to
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

to
    function setFeeProtocol uint8 feeProtocol0  uint8 feeProtocol1 external;







    function collectProtocol 
        address recipient 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;





interface IUniswapV3PoolEvents  

to
    event SetFeeProtocol uint8 feeProtocol0Old  uint8 feeProtocol1Old  uint8 feeProtocol0New  uint8 feeProtocol1New;
to
    event CollectProtocol address indexed sender  address indexed recipient  uint128 amount0  uint128 amount1;
to
        address tokenIn;
to
        address tokenOut;
to
        address tokenIn;
to
        address tokenOut;
to
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

to
    address public immutable override factory;
to
    constructor address _factory  address _WETH9  
to
        factory = _factory;
to
        require _blockTimestamp  <= deadline  'Transaction too old';
to
       @dev Returns the amount of tokens in existence 
to
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

to
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

to
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

to
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

to
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

to
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

to
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

to
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
to
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

to
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
to
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

to
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
to
    function safeTransferETH address to  uint256 value internal  
to
         bool success   = to call value: value new bytes 0;
to
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

to
        uint256 balanceToken = IERC20 token balanceOf address this;
to
        require balanceToken >= amountMinimum  'Insufficient token';
to
            TransferHelper safeTransfer token  recipient  balanceToken;
to
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

to
        if  token == WETH9 && address this balance >= value  
to
            IWETH9 WETH9 deposit value: value ;    wrap only what is needed to pay
to
            TransferHelper safeTransfer token  recipient  value;
to
            TransferHelper safeTransferFrom token  payer  recipient  value;
to
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

to
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

to
        uint256 balanceToken = IERC20 token balanceOf address this;
to
        require balanceToken >= amountMinimum  'Insufficient token';
to
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
to
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
to
   @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures  as defined in
to
   Adds the  permit method  which can be used to change an account's ERC20 allowance  see  IERC20-allowance by
to
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
to
   need to send a transaction  and thus is not required to hold Ether at all 
to
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
to
       IMPORTANT: The same issues  IERC20-approve has related to transaction
to
       Every successful call to  permit increases ``owner``'s nonce by one  This
to
    function nonces address owner external view returns  uint256;

       
       @dev Returns the domain separator used in the encoding of the signature for  permit  as defined by  EIP712 

to
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

to
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

to
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
to
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

to
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
to
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

to
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
to
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

to
        if  IERC20 token allowance msg sender  address this < type uint256 max
to
            selfPermitAllowed token  nonce  expiry  v  r  s;
to
                        mstore mc  mload cc
to
                    mstore tempBytes  _length
to
                    mstore 0x40  and add mc  31  not 31
to
                    mstore tempBytes  0
to
                    mstore 0x40  add tempBytes  0x20
to
    function toAddress bytes memory _bytes  uint256 _start internal pure returns  address  
to
        require _start + 20 >= _start  'toAddress_overflow';
to
        require _bytes length >= _start + 20  'toAddress_outOfBounds';
to
    function toUint24 bytes memory _bytes  uint256 _start internal pure returns  uint24  
to
        require _start + 3 >= _start  'toUint24_overflow';
to
        require _bytes length >= _start + 3  'toUint24_outOfBounds';
to
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

to
        tokenA = path toAddress 0;
to
        fee = path toUint24 ADDR_SIZE;
to
        tokenB = path toAddress NEXT_OFFSET;
to
        address token0;
to
        address token1;
to
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

to
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
to
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
to
    function computeAddress address factory  PoolKey memory key internal pure returns  address pool  
to
        require key token0 < key token1;
to
                        factory 
to
                        keccak256 abi encode key token0  key token1  key fee 
to
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

to
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
to
    function verifyCallback address factory  PoolAddress PoolKey memory poolKey
        internal
        view
        returns  IUniswapV3Pool pool
     

to
        pool = IUniswapV3Pool PoolAddress computeAddress factory  poolKey;
to
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
to
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

to
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
to
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
to
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
to
                ?  tokenIn < tokenOut  uint256 amount0Delta
to
                :  tokenOut < tokenIn  uint256 amount1Delta;
to
            pay tokenIn  data payer  msg sender  amountToPay;
to
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
to
                pay tokenIn  data payer  msg sender  amountToPay;
to
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
to
        bool zeroForOne = tokenIn < tokenOut;
to
            getPool tokenIn  tokenOut  fee swap 
to
                amountIn toInt256  
to
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
to
                hasMultiplePools ? address this : params recipient     for intermediate swaps  this contract custodies
to
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
to
        bool zeroForOne = tokenIn < tokenOut;
to
            getPool tokenIn  tokenOut  fee swap 
to
                -amountOut toInt256  
to
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
to
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

token
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

token
        address tokenIn;
token
        address tokenOut;
token
        address tokenIn;
token
        address tokenOut;
token
       @dev Returns the amount of tokens in existence 
token
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

token
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

token
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

token
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

token
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

token
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
token
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
token
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
token
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            TransferHelper safeTransfer token  recipient  balanceToken;
token
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

token
        if  token == WETH9 && address this balance >= value  
token
            TransferHelper safeTransfer token  recipient  value;
token
            TransferHelper safeTransferFrom token  payer  recipient  value;
token
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

token
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
token
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
token
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
token
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
token
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
token
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
token
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < type uint256 max
token
            selfPermitAllowed token  nonce  expiry  v  r  s;
token
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

token
        tokenA = path toAddress 0;
token
        tokenB = path toAddress NEXT_OFFSET;
token
        address token0;
token
        address token1;
token
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

token
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
token
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
token
        require key token0 < key token1;
token
                        keccak256 abi encode key token0  key token1  key fee 
token
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

token
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

token
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
token
                ?  tokenIn < tokenOut  uint256 amount0Delta
token
                :  tokenOut < tokenIn  uint256 amount1Delta;
token
            pay tokenIn  data payer  msg sender  amountToPay;
token
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
token
                pay tokenIn  data payer  msg sender  amountToPay;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
token
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
token
    function toUint160 uint256 y internal pure returns  uint160 z  
to
    function toInt128 int256 y internal pure returns  int128 z  
to
    function toInt256 uint256 y internal pure returns  int256 z  
to
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

to
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

to
    function setFeeProtocol uint8 feeProtocol0  uint8 feeProtocol1 external;







    function collectProtocol 
        address recipient 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;





interface IUniswapV3PoolEvents  

to
    event SetFeeProtocol uint8 feeProtocol0Old  uint8 feeProtocol1Old  uint8 feeProtocol0New  uint8 feeProtocol1New;
to
    event CollectProtocol address indexed sender  address indexed recipient  uint128 amount0  uint128 amount1;
to
        address tokenIn;
to
        address tokenOut;
to
        address tokenIn;
to
        address tokenOut;
to
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

to
    address public immutable override factory;
to
    constructor address _factory  address _WETH9  
to
        factory = _factory;
to
        require _blockTimestamp  <= deadline  'Transaction too old';
to
       @dev Returns the amount of tokens in existence 
to
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

to
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

to
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

to
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

to
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

to
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

to
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

to
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
to
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

to
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
to
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

to
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
to
    function safeTransferETH address to  uint256 value internal  
to
         bool success   = to call value: value new bytes 0;
to
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

to
        uint256 balanceToken = IERC20 token balanceOf address this;
to
        require balanceToken >= amountMinimum  'Insufficient token';
to
            TransferHelper safeTransfer token  recipient  balanceToken;
to
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

to
        if  token == WETH9 && address this balance >= value  
to
            IWETH9 WETH9 deposit value: value ;    wrap only what is needed to pay
to
            TransferHelper safeTransfer token  recipient  value;
to
            TransferHelper safeTransferFrom token  payer  recipient  value;
to
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

to
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

to
        uint256 balanceToken = IERC20 token balanceOf address this;
to
        require balanceToken >= amountMinimum  'Insufficient token';
to
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
to
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
to
   @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures  as defined in
to
   Adds the  permit method  which can be used to change an account's ERC20 allowance  see  IERC20-allowance by
to
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
to
   need to send a transaction  and thus is not required to hold Ether at all 
to
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
to
       IMPORTANT: The same issues  IERC20-approve has related to transaction
to
       Every successful call to  permit increases ``owner``'s nonce by one  This
to
    function nonces address owner external view returns  uint256;

       
       @dev Returns the domain separator used in the encoding of the signature for  permit  as defined by  EIP712 

to
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

to
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

to
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
to
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

to
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
to
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

to
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
to
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

to
        if  IERC20 token allowance msg sender  address this < type uint256 max
to
            selfPermitAllowed token  nonce  expiry  v  r  s;
to
                        mstore mc  mload cc
to
                    mstore tempBytes  _length
to
                    mstore 0x40  and add mc  31  not 31
to
                    mstore tempBytes  0
to
                    mstore 0x40  add tempBytes  0x20
to
    function toAddress bytes memory _bytes  uint256 _start internal pure returns  address  
to
        require _start + 20 >= _start  'toAddress_overflow';
to
        require _bytes length >= _start + 20  'toAddress_outOfBounds';
to
    function toUint24 bytes memory _bytes  uint256 _start internal pure returns  uint24  
to
        require _start + 3 >= _start  'toUint24_overflow';
to
        require _bytes length >= _start + 3  'toUint24_outOfBounds';
to
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

to
        tokenA = path toAddress 0;
to
        fee = path toUint24 ADDR_SIZE;
to
        tokenB = path toAddress NEXT_OFFSET;
to
        address token0;
to
        address token1;
to
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

to
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
to
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
to
    function computeAddress address factory  PoolKey memory key internal pure returns  address pool  
to
        require key token0 < key token1;
to
                        factory 
to
                        keccak256 abi encode key token0  key token1  key fee 
to
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

to
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
to
    function verifyCallback address factory  PoolAddress PoolKey memory poolKey
        internal
        view
        returns  IUniswapV3Pool pool
     

to
        pool = IUniswapV3Pool PoolAddress computeAddress factory  poolKey;
to
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
to
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

to
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
to
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
to
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
to
                ?  tokenIn < tokenOut  uint256 amount0Delta
to
                :  tokenOut < tokenIn  uint256 amount1Delta;
to
            pay tokenIn  data payer  msg sender  amountToPay;
to
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
to
                pay tokenIn  data payer  msg sender  amountToPay;
to
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
to
        bool zeroForOne = tokenIn < tokenOut;
to
            getPool tokenIn  tokenOut  fee swap 
to
                amountIn toInt256  
to
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
to
                hasMultiplePools ? address this : params recipient     for intermediate swaps  this contract custodies
to
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
to
        bool zeroForOne = tokenIn < tokenOut;
to
            getPool tokenIn  tokenOut  fee swap 
to
                -amountOut toInt256  
to
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
to
    function toUint160 uint256 y internal pure returns  uint160 z  
to
    function toInt128 int256 y internal pure returns  int128 z  
to
    function toInt256 uint256 y internal pure returns  int256 z  
to
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

to
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

to
    function setFeeProtocol uint8 feeProtocol0  uint8 feeProtocol1 external;







    function collectProtocol 
        address recipient 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;





interface IUniswapV3PoolEvents  

to
    event SetFeeProtocol uint8 feeProtocol0Old  uint8 feeProtocol1Old  uint8 feeProtocol0New  uint8 feeProtocol1New;
to
    event CollectProtocol address indexed sender  address indexed recipient  uint128 amount0  uint128 amount1;
to
        address tokenIn;
to
        address tokenOut;
to
        address tokenIn;
to
        address tokenOut;
to
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

to
    address public immutable override factory;
to
    constructor address _factory  address _WETH9  
to
        factory = _factory;
to
        require _blockTimestamp  <= deadline  'Transaction too old';
to
       @dev Returns the amount of tokens in existence 
to
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

to
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

to
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

to
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

to
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

to
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

to
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

to
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
to
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

to
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
to
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

to
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
to
    function safeTransferETH address to  uint256 value internal  
to
         bool success   = to call value: value new bytes 0;
to
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

to
        uint256 balanceToken = IERC20 token balanceOf address this;
to
        require balanceToken >= amountMinimum  'Insufficient token';
to
            TransferHelper safeTransfer token  recipient  balanceToken;
to
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

to
        if  token == WETH9 && address this balance >= value  
to
            IWETH9 WETH9 deposit value: value ;    wrap only what is needed to pay
to
            TransferHelper safeTransfer token  recipient  value;
to
            TransferHelper safeTransferFrom token  payer  recipient  value;
to
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

to
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

to
        uint256 balanceToken = IERC20 token balanceOf address this;
to
        require balanceToken >= amountMinimum  'Insufficient token';
to
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
to
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
to
   @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures  as defined in
to
   Adds the  permit method  which can be used to change an account's ERC20 allowance  see  IERC20-allowance by
to
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
to
   need to send a transaction  and thus is not required to hold Ether at all 
to
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
to
       IMPORTANT: The same issues  IERC20-approve has related to transaction
to
       Every successful call to  permit increases ``owner``'s nonce by one  This
to
    function nonces address owner external view returns  uint256;

       
       @dev Returns the domain separator used in the encoding of the signature for  permit  as defined by  EIP712 

to
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

to
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

to
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
to
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

to
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
to
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

to
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
to
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

to
        if  IERC20 token allowance msg sender  address this < type uint256 max
to
            selfPermitAllowed token  nonce  expiry  v  r  s;
to
                        mstore mc  mload cc
to
                    mstore tempBytes  _length
to
                    mstore 0x40  and add mc  31  not 31
to
                    mstore tempBytes  0
to
                    mstore 0x40  add tempBytes  0x20
to
    function toAddress bytes memory _bytes  uint256 _start internal pure returns  address  
to
        require _start + 20 >= _start  'toAddress_overflow';
to
        require _bytes length >= _start + 20  'toAddress_outOfBounds';
to
    function toUint24 bytes memory _bytes  uint256 _start internal pure returns  uint24  
to
        require _start + 3 >= _start  'toUint24_overflow';
to
        require _bytes length >= _start + 3  'toUint24_outOfBounds';
to
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

to
        tokenA = path toAddress 0;
to
        fee = path toUint24 ADDR_SIZE;
to
        tokenB = path toAddress NEXT_OFFSET;
to
        address token0;
to
        address token1;
to
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

to
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
to
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
to
    function computeAddress address factory  PoolKey memory key internal pure returns  address pool  
to
        require key token0 < key token1;
to
                        factory 
to
                        keccak256 abi encode key token0  key token1  key fee 
to
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

to
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
to
    function verifyCallback address factory  PoolAddress PoolKey memory poolKey
        internal
        view
        returns  IUniswapV3Pool pool
     

to
        pool = IUniswapV3Pool PoolAddress computeAddress factory  poolKey;
to
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
to
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

to
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
to
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
to
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
to
                ?  tokenIn < tokenOut  uint256 amount0Delta
to
                :  tokenOut < tokenIn  uint256 amount1Delta;
to
            pay tokenIn  data payer  msg sender  amountToPay;
to
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
to
                pay tokenIn  data payer  msg sender  amountToPay;
to
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
to
        bool zeroForOne = tokenIn < tokenOut;
to
            getPool tokenIn  tokenOut  fee swap 
to
                amountIn toInt256  
to
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
to
                hasMultiplePools ? address this : params recipient     for intermediate swaps  this contract custodies
to
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
to
        bool zeroForOne = tokenIn < tokenOut;
to
            getPool tokenIn  tokenOut  fee swap 
to
                -amountOut toInt256  
to
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
to
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

WETH9
    address public immutable override WETH9;
WETH9
    constructor address _factory  address _WETH9  
WETH9
        WETH9 = _WETH9;
WETH9
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

WETH9
        require msg sender == WETH9  'Not WETH9';
WETH9
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
WETH9
        uint256 balanceWETH9 = IWETH9 WETH9 balanceOf address this;
WETH9
        require balanceWETH9 >= amountMinimum  'Insufficient WETH9';
WETH9
        if  balanceWETH9 > 0  
WETH9
            IWETH9 WETH9 withdraw balanceWETH9;
WETH9
            TransferHelper safeTransferETH recipient  balanceWETH9;
WETH9
        if  token == WETH9 && address this balance >= value  
WETH9
            IWETH9 WETH9 deposit value: value ;    wrap only what is needed to pay
WETH9
            IWETH9 WETH9 transfer recipient  value;
WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

WETH9
        uint256 balanceWETH9 = IWETH9 WETH9 balanceOf address this;
WETH9
        require balanceWETH9 >= amountMinimum  'Insufficient WETH9';
WETH9
        if  balanceWETH9 > 0  
WETH9
            IWETH9 WETH9 withdraw balanceWETH9;
WETH9
            uint256 feeAmount = balanceWETH9 mul feeBips   10_000;
WETH9
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
WETH9
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
WETH9
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

WETH9
    address public immutable override WETH9;
WETH9
    constructor address _factory  address _WETH9  
WETH9
        WETH9 = _WETH9;
WETH9
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

WETH9
        require msg sender == WETH9  'Not WETH9';
WETH9
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
WETH9
        uint256 balanceWETH9 = IWETH9 WETH9 balanceOf address this;
WETH9
        require balanceWETH9 >= amountMinimum  'Insufficient WETH9';
WETH9
        if  balanceWETH9 > 0  
WETH9
            IWETH9 WETH9 withdraw balanceWETH9;
WETH9
            TransferHelper safeTransferETH recipient  balanceWETH9;
WETH9
        if  token == WETH9 && address this balance >= value  
WETH9
            IWETH9 WETH9 deposit value: value ;    wrap only what is needed to pay
WETH9
            IWETH9 WETH9 transfer recipient  value;
WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

WETH9
        uint256 balanceWETH9 = IWETH9 WETH9 balanceOf address this;
WETH9
        require balanceWETH9 >= amountMinimum  'Insufficient WETH9';
WETH9
        if  balanceWETH9 > 0  
WETH9
            IWETH9 WETH9 withdraw balanceWETH9;
WETH9
            uint256 feeAmount = balanceWETH9 mul feeBips   10_000;
WETH9
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
WETH9
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
WETH9
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

WETH9
    address public immutable override WETH9;
WETH9
    constructor address _factory  address _WETH9  
WETH9
        WETH9 = _WETH9;
WETH9
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

WETH9
        require msg sender == WETH9  'Not WETH9';
WETH9
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
WETH9
        uint256 balanceWETH9 = IWETH9 WETH9 balanceOf address this;
WETH9
        require balanceWETH9 >= amountMinimum  'Insufficient WETH9';
WETH9
        if  balanceWETH9 > 0  
WETH9
            IWETH9 WETH9 withdraw balanceWETH9;
WETH9
            TransferHelper safeTransferETH recipient  balanceWETH9;
WETH9
        if  token == WETH9 && address this balance >= value  
WETH9
            IWETH9 WETH9 deposit value: value ;    wrap only what is needed to pay
WETH9
            IWETH9 WETH9 transfer recipient  value;
WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

WETH9
        uint256 balanceWETH9 = IWETH9 WETH9 balanceOf address this;
WETH9
        require balanceWETH9 >= amountMinimum  'Insufficient WETH9';
WETH9
        if  balanceWETH9 > 0  
WETH9
            IWETH9 WETH9 withdraw balanceWETH9;
WETH9
            uint256 feeAmount = balanceWETH9 mul feeBips   10_000;
WETH9
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
WETH9
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
WETH9
    function initialize uint160 sqrtPriceX96 external;












    function mint 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount 
        bytes calldata data
     external returns  uint256 amount0  uint256 amount1;













    function collect 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;









    function burn 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount
     external returns  uint256 amount0  uint256 amount1;











    function swap 
        address recipient 
        bool zeroForOne 
        int256 amountSpecified 
        uint160 sqrtPriceLimitX96 
        bytes calldata data
     external returns  int256 amount0  int256 amount1;









    function flash 
        address recipient 
        uint256 amount0 
        uint256 amount1 
        bytes calldata data
     external;





    function increaseObservationCardinalityNext uint16 observationCardinalityNext external;




interface IUniswapV3PoolOwnerActions  

recipient
    function setFeeProtocol uint8 feeProtocol0  uint8 feeProtocol1 external;







    function collectProtocol 
        address recipient 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;





interface IUniswapV3PoolEvents  

recipient
        address recipient 
recipient
        address indexed recipient 
recipient
        address indexed recipient 
recipient
    event CollectProtocol address indexed sender  address indexed recipient  uint128 amount0  uint128 amount1;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

recipient
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
recipient
            TransferHelper safeTransferETH recipient  balanceWETH9;
recipient
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken;
recipient
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

recipient
            IWETH9 WETH9 transfer recipient  value;
recipient
            TransferHelper safeTransfer token  recipient  value;
recipient
            TransferHelper safeTransferFrom token  payer  recipient  value;
recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
recipient
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
recipient
    function exactInputInternal 
        uint256 amountIn 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountOut  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
                hasMultiplePools ? address this : params recipient     for intermediate swaps  this contract custodies
recipient
    function exactOutputInternal 
        uint256 amountOut 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountIn  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
            params recipient 
recipient
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

token
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

token
        address tokenIn;
token
        address tokenOut;
token
        address tokenIn;
token
        address tokenOut;
token
       @dev Returns the amount of tokens in existence 
token
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

token
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

token
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

token
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

token
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

token
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
token
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
token
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
token
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            TransferHelper safeTransfer token  recipient  balanceToken;
token
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

token
        if  token == WETH9 && address this balance >= value  
token
            TransferHelper safeTransfer token  recipient  value;
token
            TransferHelper safeTransferFrom token  payer  recipient  value;
token
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

token
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
token
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
token
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
token
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
token
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
token
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
token
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < type uint256 max
token
            selfPermitAllowed token  nonce  expiry  v  r  s;
token
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

token
        tokenA = path toAddress 0;
token
        tokenB = path toAddress NEXT_OFFSET;
token
        address token0;
token
        address token1;
token
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

token
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
token
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
token
        require key token0 < key token1;
token
                        keccak256 abi encode key token0  key token1  key fee 
token
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

token
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

token
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
token
                ?  tokenIn < tokenOut  uint256 amount0Delta
token
                :  tokenOut < tokenIn  uint256 amount1Delta;
token
            pay tokenIn  data payer  msg sender  amountToPay;
token
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
token
                pay tokenIn  data payer  msg sender  amountToPay;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
token
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
token
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

token
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

token
        address tokenIn;
token
        address tokenOut;
token
        address tokenIn;
token
        address tokenOut;
token
       @dev Returns the amount of tokens in existence 
token
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

token
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

token
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

token
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

token
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

token
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
token
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
token
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
token
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            TransferHelper safeTransfer token  recipient  balanceToken;
token
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

token
        if  token == WETH9 && address this balance >= value  
token
            TransferHelper safeTransfer token  recipient  value;
token
            TransferHelper safeTransferFrom token  payer  recipient  value;
token
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

token
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
token
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
token
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
token
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
token
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
token
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
token
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < type uint256 max
token
            selfPermitAllowed token  nonce  expiry  v  r  s;
token
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

token
        tokenA = path toAddress 0;
token
        tokenB = path toAddress NEXT_OFFSET;
token
        address token0;
token
        address token1;
token
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

token
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
token
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
token
        require key token0 < key token1;
token
                        keccak256 abi encode key token0  key token1  key fee 
token
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

token
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

token
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
token
                ?  tokenIn < tokenOut  uint256 amount0Delta
token
                :  tokenOut < tokenIn  uint256 amount1Delta;
token
            pay tokenIn  data payer  msg sender  amountToPay;
token
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
token
                pay tokenIn  data payer  msg sender  amountToPay;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
token
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
token
    function initialize uint160 sqrtPriceX96 external;












    function mint 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount 
        bytes calldata data
     external returns  uint256 amount0  uint256 amount1;













    function collect 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;









    function burn 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount
     external returns  uint256 amount0  uint256 amount1;











    function swap 
        address recipient 
        bool zeroForOne 
        int256 amountSpecified 
        uint160 sqrtPriceLimitX96 
        bytes calldata data
     external returns  int256 amount0  int256 amount1;









    function flash 
        address recipient 
        uint256 amount0 
        uint256 amount1 
        bytes calldata data
     external;





    function increaseObservationCardinalityNext uint16 observationCardinalityNext external;




interface IUniswapV3PoolOwnerActions  

recipient
    function setFeeProtocol uint8 feeProtocol0  uint8 feeProtocol1 external;







    function collectProtocol 
        address recipient 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;





interface IUniswapV3PoolEvents  

recipient
        address recipient 
recipient
        address indexed recipient 
recipient
        address indexed recipient 
recipient
    event CollectProtocol address indexed sender  address indexed recipient  uint128 amount0  uint128 amount1;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

recipient
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
recipient
            TransferHelper safeTransferETH recipient  balanceWETH9;
recipient
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken;
recipient
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

recipient
            IWETH9 WETH9 transfer recipient  value;
recipient
            TransferHelper safeTransfer token  recipient  value;
recipient
            TransferHelper safeTransferFrom token  payer  recipient  value;
recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
recipient
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
recipient
    function exactInputInternal 
        uint256 amountIn 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountOut  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
                hasMultiplePools ? address this : params recipient     for intermediate swaps  this contract custodies
recipient
    function exactOutputInternal 
        uint256 amountOut 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountIn  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
            params recipient 
recipient
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

token
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

token
        address tokenIn;
token
        address tokenOut;
token
        address tokenIn;
token
        address tokenOut;
token
       @dev Returns the amount of tokens in existence 
token
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

token
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

token
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

token
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

token
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

token
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
token
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
token
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
token
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            TransferHelper safeTransfer token  recipient  balanceToken;
token
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

token
        if  token == WETH9 && address this balance >= value  
token
            TransferHelper safeTransfer token  recipient  value;
token
            TransferHelper safeTransferFrom token  payer  recipient  value;
token
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

token
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
token
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
token
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
token
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
token
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
token
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
token
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < type uint256 max
token
            selfPermitAllowed token  nonce  expiry  v  r  s;
token
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

token
        tokenA = path toAddress 0;
token
        tokenB = path toAddress NEXT_OFFSET;
token
        address token0;
token
        address token1;
token
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

token
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
token
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
token
        require key token0 < key token1;
token
                        keccak256 abi encode key token0  key token1  key fee 
token
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

token
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

token
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
token
                ?  tokenIn < tokenOut  uint256 amount0Delta
token
                :  tokenOut < tokenIn  uint256 amount1Delta;
token
            pay tokenIn  data payer  msg sender  amountToPay;
token
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
token
                pay tokenIn  data payer  msg sender  amountToPay;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
token
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
token
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

WETH9
    address public immutable override WETH9;
WETH9
    constructor address _factory  address _WETH9  
WETH9
        WETH9 = _WETH9;
WETH9
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

WETH9
        require msg sender == WETH9  'Not WETH9';
WETH9
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
WETH9
        uint256 balanceWETH9 = IWETH9 WETH9 balanceOf address this;
WETH9
        require balanceWETH9 >= amountMinimum  'Insufficient WETH9';
WETH9
        if  balanceWETH9 > 0  
WETH9
            IWETH9 WETH9 withdraw balanceWETH9;
WETH9
            TransferHelper safeTransferETH recipient  balanceWETH9;
WETH9
        if  token == WETH9 && address this balance >= value  
WETH9
            IWETH9 WETH9 deposit value: value ;    wrap only what is needed to pay
WETH9
            IWETH9 WETH9 transfer recipient  value;
WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

WETH9
        uint256 balanceWETH9 = IWETH9 WETH9 balanceOf address this;
WETH9
        require balanceWETH9 >= amountMinimum  'Insufficient WETH9';
WETH9
        if  balanceWETH9 > 0  
WETH9
            IWETH9 WETH9 withdraw balanceWETH9;
WETH9
            uint256 feeAmount = balanceWETH9 mul feeBips   10_000;
WETH9
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
WETH9
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
WETH9
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

WETH9
    address public immutable override WETH9;
WETH9
    constructor address _factory  address _WETH9  
WETH9
        WETH9 = _WETH9;
WETH9
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

WETH9
        require msg sender == WETH9  'Not WETH9';
WETH9
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
WETH9
        uint256 balanceWETH9 = IWETH9 WETH9 balanceOf address this;
WETH9
        require balanceWETH9 >= amountMinimum  'Insufficient WETH9';
WETH9
        if  balanceWETH9 > 0  
WETH9
            IWETH9 WETH9 withdraw balanceWETH9;
WETH9
            TransferHelper safeTransferETH recipient  balanceWETH9;
WETH9
        if  token == WETH9 && address this balance >= value  
WETH9
            IWETH9 WETH9 deposit value: value ;    wrap only what is needed to pay
WETH9
            IWETH9 WETH9 transfer recipient  value;
WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

WETH9
        uint256 balanceWETH9 = IWETH9 WETH9 balanceOf address this;
WETH9
        require balanceWETH9 >= amountMinimum  'Insufficient WETH9';
WETH9
        if  balanceWETH9 > 0  
WETH9
            IWETH9 WETH9 withdraw balanceWETH9;
WETH9
            uint256 feeAmount = balanceWETH9 mul feeBips   10_000;
WETH9
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
WETH9
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
WETH9
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

WETH9
    address public immutable override WETH9;
WETH9
    constructor address _factory  address _WETH9  
WETH9
        WETH9 = _WETH9;
WETH9
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

WETH9
        require msg sender == WETH9  'Not WETH9';
WETH9
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
WETH9
        uint256 balanceWETH9 = IWETH9 WETH9 balanceOf address this;
WETH9
        require balanceWETH9 >= amountMinimum  'Insufficient WETH9';
WETH9
        if  balanceWETH9 > 0  
WETH9
            IWETH9 WETH9 withdraw balanceWETH9;
WETH9
            TransferHelper safeTransferETH recipient  balanceWETH9;
WETH9
        if  token == WETH9 && address this balance >= value  
WETH9
            IWETH9 WETH9 deposit value: value ;    wrap only what is needed to pay
WETH9
            IWETH9 WETH9 transfer recipient  value;
WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

WETH9
        uint256 balanceWETH9 = IWETH9 WETH9 balanceOf address this;
WETH9
        require balanceWETH9 >= amountMinimum  'Insufficient WETH9';
WETH9
        if  balanceWETH9 > 0  
WETH9
            IWETH9 WETH9 withdraw balanceWETH9;
WETH9
            uint256 feeAmount = balanceWETH9 mul feeBips   10_000;
WETH9
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
WETH9
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
WETH9
    function initialize uint160 sqrtPriceX96 external;












    function mint 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount 
        bytes calldata data
     external returns  uint256 amount0  uint256 amount1;













    function collect 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;









    function burn 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount
     external returns  uint256 amount0  uint256 amount1;











    function swap 
        address recipient 
        bool zeroForOne 
        int256 amountSpecified 
        uint160 sqrtPriceLimitX96 
        bytes calldata data
     external returns  int256 amount0  int256 amount1;









    function flash 
        address recipient 
        uint256 amount0 
        uint256 amount1 
        bytes calldata data
     external;





    function increaseObservationCardinalityNext uint16 observationCardinalityNext external;




interface IUniswapV3PoolOwnerActions  

recipient
    function setFeeProtocol uint8 feeProtocol0  uint8 feeProtocol1 external;







    function collectProtocol 
        address recipient 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;





interface IUniswapV3PoolEvents  

recipient
        address recipient 
recipient
        address indexed recipient 
recipient
        address indexed recipient 
recipient
    event CollectProtocol address indexed sender  address indexed recipient  uint128 amount0  uint128 amount1;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

recipient
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
recipient
            TransferHelper safeTransferETH recipient  balanceWETH9;
recipient
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken;
recipient
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

recipient
            IWETH9 WETH9 transfer recipient  value;
recipient
            TransferHelper safeTransfer token  recipient  value;
recipient
            TransferHelper safeTransferFrom token  payer  recipient  value;
recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
recipient
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
recipient
    function exactInputInternal 
        uint256 amountIn 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountOut  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
                hasMultiplePools ? address this : params recipient     for intermediate swaps  this contract custodies
recipient
    function exactOutputInternal 
        uint256 amountOut 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountIn  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
            params recipient 
recipient
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

payer
         else if  payer == address this  
payer
            TransferHelper safeTransferFrom token  payer  recipient  value;
payer
        address payer;
payer
            pay tokenIn  data payer  msg sender  amountToPay;
payer
                pay tokenIn  data payer  msg sender  amountToPay;
payer
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
payer
        address payer = msg sender;    msg sender pays for the first hop
payer
                    payer: payer
payer
                payer = address this;    at this point  the caller has paid
payer
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
payer
            SwapCallbackData  path: params path  payer: msg sender
payer
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

token
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

token
        address tokenIn;
token
        address tokenOut;
token
        address tokenIn;
token
        address tokenOut;
token
       @dev Returns the amount of tokens in existence 
token
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

token
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

token
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

token
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

token
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

token
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
token
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
token
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
token
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            TransferHelper safeTransfer token  recipient  balanceToken;
token
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

token
        if  token == WETH9 && address this balance >= value  
token
            TransferHelper safeTransfer token  recipient  value;
token
            TransferHelper safeTransferFrom token  payer  recipient  value;
token
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

token
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
token
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
token
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
token
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
token
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
token
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
token
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < type uint256 max
token
            selfPermitAllowed token  nonce  expiry  v  r  s;
token
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

token
        tokenA = path toAddress 0;
token
        tokenB = path toAddress NEXT_OFFSET;
token
        address token0;
token
        address token1;
token
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

token
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
token
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
token
        require key token0 < key token1;
token
                        keccak256 abi encode key token0  key token1  key fee 
token
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

token
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

token
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
token
                ?  tokenIn < tokenOut  uint256 amount0Delta
token
                :  tokenOut < tokenIn  uint256 amount1Delta;
token
            pay tokenIn  data payer  msg sender  amountToPay;
token
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
token
                pay tokenIn  data payer  msg sender  amountToPay;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
token
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
token
    function initialize uint160 sqrtPriceX96 external;












    function mint 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount 
        bytes calldata data
     external returns  uint256 amount0  uint256 amount1;













    function collect 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;









    function burn 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount
     external returns  uint256 amount0  uint256 amount1;











    function swap 
        address recipient 
        bool zeroForOne 
        int256 amountSpecified 
        uint160 sqrtPriceLimitX96 
        bytes calldata data
     external returns  int256 amount0  int256 amount1;









    function flash 
        address recipient 
        uint256 amount0 
        uint256 amount1 
        bytes calldata data
     external;





    function increaseObservationCardinalityNext uint16 observationCardinalityNext external;




interface IUniswapV3PoolOwnerActions  

recipient
    function setFeeProtocol uint8 feeProtocol0  uint8 feeProtocol1 external;







    function collectProtocol 
        address recipient 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;





interface IUniswapV3PoolEvents  

recipient
        address recipient 
recipient
        address indexed recipient 
recipient
        address indexed recipient 
recipient
    event CollectProtocol address indexed sender  address indexed recipient  uint128 amount0  uint128 amount1;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

recipient
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
recipient
            TransferHelper safeTransferETH recipient  balanceWETH9;
recipient
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken;
recipient
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

recipient
            IWETH9 WETH9 transfer recipient  value;
recipient
            TransferHelper safeTransfer token  recipient  value;
recipient
            TransferHelper safeTransferFrom token  payer  recipient  value;
recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
recipient
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
recipient
    function exactInputInternal 
        uint256 amountIn 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountOut  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
                hasMultiplePools ? address this : params recipient     for intermediate swaps  this contract custodies
recipient
    function exactOutputInternal 
        uint256 amountOut 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountIn  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
            params recipient 
recipient
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

token
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

token
        address tokenIn;
token
        address tokenOut;
token
        address tokenIn;
token
        address tokenOut;
token
       @dev Returns the amount of tokens in existence 
token
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

token
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

token
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

token
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

token
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

token
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
token
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
token
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
token
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            TransferHelper safeTransfer token  recipient  balanceToken;
token
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

token
        if  token == WETH9 && address this balance >= value  
token
            TransferHelper safeTransfer token  recipient  value;
token
            TransferHelper safeTransferFrom token  payer  recipient  value;
token
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

token
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
token
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
token
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
token
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
token
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
token
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
token
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < type uint256 max
token
            selfPermitAllowed token  nonce  expiry  v  r  s;
token
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

token
        tokenA = path toAddress 0;
token
        tokenB = path toAddress NEXT_OFFSET;
token
        address token0;
token
        address token1;
token
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

token
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
token
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
token
        require key token0 < key token1;
token
                        keccak256 abi encode key token0  key token1  key fee 
token
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

token
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

token
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
token
                ?  tokenIn < tokenOut  uint256 amount0Delta
token
                :  tokenOut < tokenIn  uint256 amount1Delta;
token
            pay tokenIn  data payer  msg sender  amountToPay;
token
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
token
                pay tokenIn  data payer  msg sender  amountToPay;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
token
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
token
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

payer
         else if  payer == address this  
payer
            TransferHelper safeTransferFrom token  payer  recipient  value;
payer
        address payer;
payer
            pay tokenIn  data payer  msg sender  amountToPay;
payer
                pay tokenIn  data payer  msg sender  amountToPay;
payer
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
payer
        address payer = msg sender;    msg sender pays for the first hop
payer
                    payer: payer
payer
                payer = address this;    at this point  the caller has paid
payer
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
payer
            SwapCallbackData  path: params path  payer: msg sender
payer
    function initialize uint160 sqrtPriceX96 external;












    function mint 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount 
        bytes calldata data
     external returns  uint256 amount0  uint256 amount1;













    function collect 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;









    function burn 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount
     external returns  uint256 amount0  uint256 amount1;











    function swap 
        address recipient 
        bool zeroForOne 
        int256 amountSpecified 
        uint160 sqrtPriceLimitX96 
        bytes calldata data
     external returns  int256 amount0  int256 amount1;









    function flash 
        address recipient 
        uint256 amount0 
        uint256 amount1 
        bytes calldata data
     external;





    function increaseObservationCardinalityNext uint16 observationCardinalityNext external;




interface IUniswapV3PoolOwnerActions  

recipient
    function setFeeProtocol uint8 feeProtocol0  uint8 feeProtocol1 external;







    function collectProtocol 
        address recipient 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;





interface IUniswapV3PoolEvents  

recipient
        address recipient 
recipient
        address indexed recipient 
recipient
        address indexed recipient 
recipient
    event CollectProtocol address indexed sender  address indexed recipient  uint128 amount0  uint128 amount1;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

recipient
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
recipient
            TransferHelper safeTransferETH recipient  balanceWETH9;
recipient
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken;
recipient
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

recipient
            IWETH9 WETH9 transfer recipient  value;
recipient
            TransferHelper safeTransfer token  recipient  value;
recipient
            TransferHelper safeTransferFrom token  payer  recipient  value;
recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
recipient
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
recipient
    function exactInputInternal 
        uint256 amountIn 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountOut  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
                hasMultiplePools ? address this : params recipient     for intermediate swaps  this contract custodies
recipient
    function exactOutputInternal 
        uint256 amountOut 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountIn  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
            params recipient 
recipient
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

WETH9
    address public immutable override WETH9;
WETH9
    constructor address _factory  address _WETH9  
WETH9
        WETH9 = _WETH9;
WETH9
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

WETH9
        require msg sender == WETH9  'Not WETH9';
WETH9
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
WETH9
        uint256 balanceWETH9 = IWETH9 WETH9 balanceOf address this;
WETH9
        require balanceWETH9 >= amountMinimum  'Insufficient WETH9';
WETH9
        if  balanceWETH9 > 0  
WETH9
            IWETH9 WETH9 withdraw balanceWETH9;
WETH9
            TransferHelper safeTransferETH recipient  balanceWETH9;
WETH9
        if  token == WETH9 && address this balance >= value  
WETH9
            IWETH9 WETH9 deposit value: value ;    wrap only what is needed to pay
WETH9
            IWETH9 WETH9 transfer recipient  value;
WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

WETH9
        uint256 balanceWETH9 = IWETH9 WETH9 balanceOf address this;
WETH9
        require balanceWETH9 >= amountMinimum  'Insufficient WETH9';
WETH9
        if  balanceWETH9 > 0  
WETH9
            IWETH9 WETH9 withdraw balanceWETH9;
WETH9
            uint256 feeAmount = balanceWETH9 mul feeBips   10_000;
WETH9
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
WETH9
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
WETH9
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

WETH9
    address public immutable override WETH9;
WETH9
    constructor address _factory  address _WETH9  
WETH9
        WETH9 = _WETH9;
WETH9
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

WETH9
        require msg sender == WETH9  'Not WETH9';
WETH9
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
WETH9
        uint256 balanceWETH9 = IWETH9 WETH9 balanceOf address this;
WETH9
        require balanceWETH9 >= amountMinimum  'Insufficient WETH9';
WETH9
        if  balanceWETH9 > 0  
WETH9
            IWETH9 WETH9 withdraw balanceWETH9;
WETH9
            TransferHelper safeTransferETH recipient  balanceWETH9;
WETH9
        if  token == WETH9 && address this balance >= value  
WETH9
            IWETH9 WETH9 deposit value: value ;    wrap only what is needed to pay
WETH9
            IWETH9 WETH9 transfer recipient  value;
WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

WETH9
        uint256 balanceWETH9 = IWETH9 WETH9 balanceOf address this;
WETH9
        require balanceWETH9 >= amountMinimum  'Insufficient WETH9';
WETH9
        if  balanceWETH9 > 0  
WETH9
            IWETH9 WETH9 withdraw balanceWETH9;
WETH9
            uint256 feeAmount = balanceWETH9 mul feeBips   10_000;
WETH9
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
WETH9
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
WETH9
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

feeRecipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

feeRecipient
            if  feeAmount > 0 TransferHelper safeTransferETH feeRecipient  feeAmount;
feeRecipient
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

feeRecipient
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
feeRecipient
    function initialize uint160 sqrtPriceX96 external;












    function mint 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount 
        bytes calldata data
     external returns  uint256 amount0  uint256 amount1;













    function collect 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;









    function burn 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount
     external returns  uint256 amount0  uint256 amount1;











    function swap 
        address recipient 
        bool zeroForOne 
        int256 amountSpecified 
        uint160 sqrtPriceLimitX96 
        bytes calldata data
     external returns  int256 amount0  int256 amount1;









    function flash 
        address recipient 
        uint256 amount0 
        uint256 amount1 
        bytes calldata data
     external;





    function increaseObservationCardinalityNext uint16 observationCardinalityNext external;




interface IUniswapV3PoolOwnerActions  

recipient
    function setFeeProtocol uint8 feeProtocol0  uint8 feeProtocol1 external;







    function collectProtocol 
        address recipient 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;





interface IUniswapV3PoolEvents  

recipient
        address recipient 
recipient
        address indexed recipient 
recipient
        address indexed recipient 
recipient
    event CollectProtocol address indexed sender  address indexed recipient  uint128 amount0  uint128 amount1;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

recipient
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
recipient
            TransferHelper safeTransferETH recipient  balanceWETH9;
recipient
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken;
recipient
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

recipient
            IWETH9 WETH9 transfer recipient  value;
recipient
            TransferHelper safeTransfer token  recipient  value;
recipient
            TransferHelper safeTransferFrom token  payer  recipient  value;
recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
recipient
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
recipient
    function exactInputInternal 
        uint256 amountIn 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountOut  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
                hasMultiplePools ? address this : params recipient     for intermediate swaps  this contract custodies
recipient
    function exactOutputInternal 
        uint256 amountOut 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountIn  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
            params recipient 
recipient
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

token
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

token
        address tokenIn;
token
        address tokenOut;
token
        address tokenIn;
token
        address tokenOut;
token
       @dev Returns the amount of tokens in existence 
token
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

token
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

token
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

token
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

token
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

token
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
token
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
token
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
token
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            TransferHelper safeTransfer token  recipient  balanceToken;
token
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

token
        if  token == WETH9 && address this balance >= value  
token
            TransferHelper safeTransfer token  recipient  value;
token
            TransferHelper safeTransferFrom token  payer  recipient  value;
token
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

token
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
token
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
token
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
token
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
token
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
token
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
token
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < type uint256 max
token
            selfPermitAllowed token  nonce  expiry  v  r  s;
token
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

token
        tokenA = path toAddress 0;
token
        tokenB = path toAddress NEXT_OFFSET;
token
        address token0;
token
        address token1;
token
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

token
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
token
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
token
        require key token0 < key token1;
token
                        keccak256 abi encode key token0  key token1  key fee 
token
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

token
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

token
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
token
                ?  tokenIn < tokenOut  uint256 amount0Delta
token
                :  tokenOut < tokenIn  uint256 amount1Delta;
token
            pay tokenIn  data payer  msg sender  amountToPay;
token
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
token
                pay tokenIn  data payer  msg sender  amountToPay;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
token
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
token
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

token
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

token
        address tokenIn;
token
        address tokenOut;
token
        address tokenIn;
token
        address tokenOut;
token
       @dev Returns the amount of tokens in existence 
token
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

token
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

token
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

token
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

token
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

token
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
token
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
token
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
token
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            TransferHelper safeTransfer token  recipient  balanceToken;
token
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

token
        if  token == WETH9 && address this balance >= value  
token
            TransferHelper safeTransfer token  recipient  value;
token
            TransferHelper safeTransferFrom token  payer  recipient  value;
token
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

token
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
token
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
token
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
token
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
token
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
token
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
token
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < type uint256 max
token
            selfPermitAllowed token  nonce  expiry  v  r  s;
token
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

token
        tokenA = path toAddress 0;
token
        tokenB = path toAddress NEXT_OFFSET;
token
        address token0;
token
        address token1;
token
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

token
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
token
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
token
        require key token0 < key token1;
token
                        keccak256 abi encode key token0  key token1  key fee 
token
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

token
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

token
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
token
                ?  tokenIn < tokenOut  uint256 amount0Delta
token
                :  tokenOut < tokenIn  uint256 amount1Delta;
token
            pay tokenIn  data payer  msg sender  amountToPay;
token
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
token
                pay tokenIn  data payer  msg sender  amountToPay;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
token
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
token
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

feeRecipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

feeRecipient
            if  feeAmount > 0 TransferHelper safeTransferETH feeRecipient  feeAmount;
feeRecipient
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

feeRecipient
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
feeRecipient
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

token
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

token
        address tokenIn;
token
        address tokenOut;
token
        address tokenIn;
token
        address tokenOut;
token
       @dev Returns the amount of tokens in existence 
token
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

token
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

token
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

token
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

token
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

token
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
token
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
token
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
token
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            TransferHelper safeTransfer token  recipient  balanceToken;
token
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

token
        if  token == WETH9 && address this balance >= value  
token
            TransferHelper safeTransfer token  recipient  value;
token
            TransferHelper safeTransferFrom token  payer  recipient  value;
token
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

token
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
token
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
token
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
token
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
token
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
token
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
token
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < type uint256 max
token
            selfPermitAllowed token  nonce  expiry  v  r  s;
token
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

token
        tokenA = path toAddress 0;
token
        tokenB = path toAddress NEXT_OFFSET;
token
        address token0;
token
        address token1;
token
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

token
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
token
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
token
        require key token0 < key token1;
token
                        keccak256 abi encode key token0  key token1  key fee 
token
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

token
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

token
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
token
                ?  tokenIn < tokenOut  uint256 amount0Delta
token
                :  tokenOut < tokenIn  uint256 amount1Delta;
token
            pay tokenIn  data payer  msg sender  amountToPay;
token
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
token
                pay tokenIn  data payer  msg sender  amountToPay;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
token
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
token
    function initialize uint160 sqrtPriceX96 external;












    function mint 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount 
        bytes calldata data
     external returns  uint256 amount0  uint256 amount1;













    function collect 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;









    function burn 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount
     external returns  uint256 amount0  uint256 amount1;











    function swap 
        address recipient 
        bool zeroForOne 
        int256 amountSpecified 
        uint160 sqrtPriceLimitX96 
        bytes calldata data
     external returns  int256 amount0  int256 amount1;









    function flash 
        address recipient 
        uint256 amount0 
        uint256 amount1 
        bytes calldata data
     external;





    function increaseObservationCardinalityNext uint16 observationCardinalityNext external;




interface IUniswapV3PoolOwnerActions  

recipient
    function setFeeProtocol uint8 feeProtocol0  uint8 feeProtocol1 external;







    function collectProtocol 
        address recipient 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;





interface IUniswapV3PoolEvents  

recipient
        address recipient 
recipient
        address indexed recipient 
recipient
        address indexed recipient 
recipient
    event CollectProtocol address indexed sender  address indexed recipient  uint128 amount0  uint128 amount1;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

recipient
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
recipient
            TransferHelper safeTransferETH recipient  balanceWETH9;
recipient
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken;
recipient
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

recipient
            IWETH9 WETH9 transfer recipient  value;
recipient
            TransferHelper safeTransfer token  recipient  value;
recipient
            TransferHelper safeTransferFrom token  payer  recipient  value;
recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
recipient
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
recipient
    function exactInputInternal 
        uint256 amountIn 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountOut  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
                hasMultiplePools ? address this : params recipient     for intermediate swaps  this contract custodies
recipient
    function exactOutputInternal 
        uint256 amountOut 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountIn  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
            params recipient 
recipient
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

token
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

token
        address tokenIn;
token
        address tokenOut;
token
        address tokenIn;
token
        address tokenOut;
token
       @dev Returns the amount of tokens in existence 
token
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

token
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

token
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

token
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

token
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

token
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
token
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
token
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
token
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            TransferHelper safeTransfer token  recipient  balanceToken;
token
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

token
        if  token == WETH9 && address this balance >= value  
token
            TransferHelper safeTransfer token  recipient  value;
token
            TransferHelper safeTransferFrom token  payer  recipient  value;
token
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

token
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
token
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
token
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
token
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
token
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
token
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
token
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < type uint256 max
token
            selfPermitAllowed token  nonce  expiry  v  r  s;
token
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

token
        tokenA = path toAddress 0;
token
        tokenB = path toAddress NEXT_OFFSET;
token
        address token0;
token
        address token1;
token
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

token
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
token
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
token
        require key token0 < key token1;
token
                        keccak256 abi encode key token0  key token1  key fee 
token
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

token
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

token
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
token
                ?  tokenIn < tokenOut  uint256 amount0Delta
token
                :  tokenOut < tokenIn  uint256 amount1Delta;
token
            pay tokenIn  data payer  msg sender  amountToPay;
token
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
token
                pay tokenIn  data payer  msg sender  amountToPay;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
token
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
token
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

token
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

token
        address tokenIn;
token
        address tokenOut;
token
        address tokenIn;
token
        address tokenOut;
token
       @dev Returns the amount of tokens in existence 
token
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

token
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

token
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

token
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

token
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

token
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
token
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
token
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
token
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            TransferHelper safeTransfer token  recipient  balanceToken;
token
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

token
        if  token == WETH9 && address this balance >= value  
token
            TransferHelper safeTransfer token  recipient  value;
token
            TransferHelper safeTransferFrom token  payer  recipient  value;
token
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

token
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
token
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
token
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
token
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
token
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
token
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
token
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < type uint256 max
token
            selfPermitAllowed token  nonce  expiry  v  r  s;
token
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

token
        tokenA = path toAddress 0;
token
        tokenB = path toAddress NEXT_OFFSET;
token
        address token0;
token
        address token1;
token
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

token
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
token
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
token
        require key token0 < key token1;
token
                        keccak256 abi encode key token0  key token1  key fee 
token
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

token
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

token
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
token
                ?  tokenIn < tokenOut  uint256 amount0Delta
token
                :  tokenOut < tokenIn  uint256 amount1Delta;
token
            pay tokenIn  data payer  msg sender  amountToPay;
token
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
token
                pay tokenIn  data payer  msg sender  amountToPay;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
token
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
token
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

token
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

token
        address tokenIn;
token
        address tokenOut;
token
        address tokenIn;
token
        address tokenOut;
token
       @dev Returns the amount of tokens in existence 
token
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

token
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

token
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

token
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

token
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

token
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
token
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
token
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
token
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            TransferHelper safeTransfer token  recipient  balanceToken;
token
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

token
        if  token == WETH9 && address this balance >= value  
token
            TransferHelper safeTransfer token  recipient  value;
token
            TransferHelper safeTransferFrom token  payer  recipient  value;
token
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

token
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
token
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
token
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
token
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
token
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
token
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
token
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < type uint256 max
token
            selfPermitAllowed token  nonce  expiry  v  r  s;
token
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

token
        tokenA = path toAddress 0;
token
        tokenB = path toAddress NEXT_OFFSET;
token
        address token0;
token
        address token1;
token
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

token
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
token
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
token
        require key token0 < key token1;
token
                        keccak256 abi encode key token0  key token1  key fee 
token
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

token
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

token
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
token
                ?  tokenIn < tokenOut  uint256 amount0Delta
token
                :  tokenOut < tokenIn  uint256 amount1Delta;
token
            pay tokenIn  data payer  msg sender  amountToPay;
token
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
token
                pay tokenIn  data payer  msg sender  amountToPay;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
token
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
token
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

token
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

token
        address tokenIn;
token
        address tokenOut;
token
        address tokenIn;
token
        address tokenOut;
token
       @dev Returns the amount of tokens in existence 
token
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

token
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

token
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

token
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

token
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

token
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
token
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
token
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
token
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            TransferHelper safeTransfer token  recipient  balanceToken;
token
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

token
        if  token == WETH9 && address this balance >= value  
token
            TransferHelper safeTransfer token  recipient  value;
token
            TransferHelper safeTransferFrom token  payer  recipient  value;
token
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

token
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
token
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
token
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
token
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
token
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
token
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
token
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < type uint256 max
token
            selfPermitAllowed token  nonce  expiry  v  r  s;
token
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

token
        tokenA = path toAddress 0;
token
        tokenB = path toAddress NEXT_OFFSET;
token
        address token0;
token
        address token1;
token
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

token
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
token
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
token
        require key token0 < key token1;
token
                        keccak256 abi encode key token0  key token1  key fee 
token
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

token
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

token
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
token
                ?  tokenIn < tokenOut  uint256 amount0Delta
token
                :  tokenOut < tokenIn  uint256 amount1Delta;
token
            pay tokenIn  data payer  msg sender  amountToPay;
token
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
token
                pay tokenIn  data payer  msg sender  amountToPay;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
token
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
token
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

token
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

token
        address tokenIn;
token
        address tokenOut;
token
        address tokenIn;
token
        address tokenOut;
token
       @dev Returns the amount of tokens in existence 
token
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

token
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

token
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

token
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

token
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

token
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
token
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
token
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
token
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            TransferHelper safeTransfer token  recipient  balanceToken;
token
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

token
        if  token == WETH9 && address this balance >= value  
token
            TransferHelper safeTransfer token  recipient  value;
token
            TransferHelper safeTransferFrom token  payer  recipient  value;
token
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

token
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
token
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
token
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
token
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
token
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
token
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
token
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < type uint256 max
token
            selfPermitAllowed token  nonce  expiry  v  r  s;
token
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

token
        tokenA = path toAddress 0;
token
        tokenB = path toAddress NEXT_OFFSET;
token
        address token0;
token
        address token1;
token
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

token
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
token
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
token
        require key token0 < key token1;
token
                        keccak256 abi encode key token0  key token1  key fee 
token
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

token
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

token
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
token
                ?  tokenIn < tokenOut  uint256 amount0Delta
token
                :  tokenOut < tokenIn  uint256 amount1Delta;
token
            pay tokenIn  data payer  msg sender  amountToPay;
token
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
token
                pay tokenIn  data payer  msg sender  amountToPay;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
token
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
token
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

token
    function slot0 
        external
        view
        returns  
            uint160 sqrtPriceX96 
            int24 tick 
            uint16 observationIndex 
            uint16 observationCardinality 
            uint16 observationCardinalityNext 
            uint8 feeProtocol 
            bool unlocked
        ;



    function feeGrowthGlobal0X128  external view returns  uint256;



    function feeGrowthGlobal1X128  external view returns  uint256;



    function protocolFees  external view returns  uint128 token0  uint128 token1;



    function liquidity  external view returns  uint128;















    function ticks int24 tick
        external
        view
        returns  
            uint128 liquidityGross 
            int128 liquidityNet 
            uint256 feeGrowthOutside0X128 
            uint256 feeGrowthOutside1X128 
            int56 tickCumulativeOutside 
            uint160 secondsPerLiquidityOutsideX128 
            uint32 secondsOutside 
            bool initialized
        ;


    function tickBitmap int16 wordPosition external view returns  uint256;








    function positions bytes32 key
        external
        view
        returns  
            uint128 _liquidity 
            uint256 feeGrowthInside0LastX128 
            uint256 feeGrowthInside1LastX128 
            uint128 tokensOwed0 
            uint128 tokensOwed1
        ;









    function observations uint256 index
        external
        view
        returns  
            uint32 blockTimestamp 
            int56 tickCumulative 
            uint160 secondsPerLiquidityCumulativeX128 
            bool initialized
        ;





interface IUniswapV3PoolDerivedState  

token
        address tokenIn;
token
        address tokenOut;
token
        address tokenIn;
token
        address tokenOut;
token
       @dev Returns the amount of tokens in existence 
token
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

token
    function allowance address owner  address spender external view returns  uint256;

       
       @dev Sets `amount` as the allowance of `spender` over the caller's tokens 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       IMPORTANT: Beware that changing an allowance with this method brings the risk
       that someone may use both the old and the new allowance by unfortunate
       transaction ordering  One possible solution to mitigate this race
       condition is to first reduce the spender's allowance to 0 and set the
       desired value afterwards:
       https:  github com ethereum EIPs issues 20#issuecomment-263524729
      
       Emits an  Approval event 

token
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

token
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

token
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

token
    function safeTransferFrom 
        address token 
        address from 
        address to 
        uint256 value
     internal  

token
            token call abi encodeWithSelector IERC20 transferFrom selector  from  to  value;
token
    function safeTransfer 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 transfer selector  to  value;
token
    function safeApprove 
        address token 
        address to 
        uint256 value
     internal  

token
         bool success  bytes memory data = token call abi encodeWithSelector IERC20 approve selector  to  value;
token
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            TransferHelper safeTransfer token  recipient  balanceToken;
token
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

token
        if  token == WETH9 && address this balance >= value  
token
            TransferHelper safeTransfer token  recipient  value;
token
            TransferHelper safeTransferFrom token  payer  recipient  value;
token
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

token
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

token
        uint256 balanceToken = IERC20 token balanceOf address this;
token
        require balanceToken >= amountMinimum  'Insufficient token';
token
            if  feeAmount > 0 TransferHelper safeTransfer token  feeRecipient  feeAmount;
token
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
token
   presenting a message signed by the account  By not relying on  IERC20-approve  the token holder account doesn't
token
       @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens 
token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;









    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;










    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable;




interface IERC20PermitAllowed  

token
    function selfPermit 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20Permit token permit msg sender  address this  value  deadline  v  r  s;
token
    function selfPermitIfNecessary 
        address token 
        uint256 value 
        uint256 deadline 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < value selfPermit token  value  deadline  v  r  s;
token
    function selfPermitAllowed 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     public payable override  

token
        IERC20PermitAllowed token permit msg sender  address this  nonce  expiry  true  v  r  s;
token
    function selfPermitAllowedIfNecessary 
        address token 
        uint256 nonce 
        uint256 expiry 
        uint8 v 
        bytes32 r 
        bytes32 s
     external payable override  

token
        if  IERC20 token allowance msg sender  address this < type uint256 max
token
            selfPermitAllowed token  nonce  expiry  v  r  s;
token
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

token
        tokenA = path toAddress 0;
token
        tokenB = path toAddress NEXT_OFFSET;
token
        address token0;
token
        address token1;
token
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

token
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
token
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
token
        require key token0 < key token1;
token
                        keccak256 abi encode key token0  key token1  key fee 
token
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

token
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

token
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
token
                ?  tokenIn < tokenOut  uint256 amount0Delta
token
                :  tokenOut < tokenIn  uint256 amount1Delta;
token
            pay tokenIn  data payer  msg sender  amountToPay;
token
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
token
                pay tokenIn  data payer  msg sender  amountToPay;
token
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
token
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
token
        bool zeroForOne = tokenIn < tokenOut;
token
            getPool tokenIn  tokenOut  fee swap 
token
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
token
        address tempAddress;
tempAddress
            tempAddress := div mload add add _bytes  0x20  _start  0x1000000000000000000000000
tempAddress
        return tempAddress;
tempAddress
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

tokenA
        tokenA = path toAddress 0;
tokenA
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

tokenA
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
tokenA
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
tokenA
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

tokenA
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenA
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

tokenA
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenA
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

tokenB
        tokenB = path toAddress NEXT_OFFSET;
tokenB
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

tokenB
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
tokenB
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
tokenB
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

tokenB
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenB
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

tokenB
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenB
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

tokenA
        tokenA = path toAddress 0;
tokenA
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

tokenA
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
tokenA
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
tokenA
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

tokenA
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenA
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

tokenA
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenA
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

tokenB
        tokenB = path toAddress NEXT_OFFSET;
tokenB
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

tokenB
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
tokenB
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
tokenB
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

tokenB
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenB
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

tokenB
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenB
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

tokenA
        tokenA = path toAddress 0;
tokenA
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

tokenA
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
tokenA
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
tokenA
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

tokenA
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenA
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

tokenA
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenA
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

tokenB
        tokenB = path toAddress NEXT_OFFSET;
tokenB
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

tokenB
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
tokenB
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
tokenB
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

tokenB
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenB
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

tokenB
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenB
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

tokenB
        tokenB = path toAddress NEXT_OFFSET;
tokenB
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

tokenB
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
tokenB
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
tokenB
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

tokenB
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenB
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

tokenB
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenB
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

tokenA
        tokenA = path toAddress 0;
tokenA
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

tokenA
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
tokenA
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
tokenA
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

tokenA
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenA
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

tokenA
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenA
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

tokenA
        tokenA = path toAddress 0;
tokenA
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

tokenA
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
tokenA
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
tokenA
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

tokenA
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenA
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

tokenA
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenA
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

tokenB
        tokenB = path toAddress NEXT_OFFSET;
tokenB
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

tokenB
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
tokenB
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
tokenB
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

tokenB
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenB
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

tokenB
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenB
    function computeAddress address factory  PoolKey memory key internal pure returns  address pool  
pool
        pool = address 
pool
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

pool
    function verifyCallback address factory  PoolAddress PoolKey memory poolKey
        internal
        view
        returns  IUniswapV3Pool pool
     

pool
        pool = IUniswapV3Pool PoolAddress computeAddress factory  poolKey;
pool
        require msg sender == address pool;
pool
                    path: params path getFirstPool      only the first pool in the path is necessary
pool
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

factory
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

factory
    address public immutable override factory;
factory
    constructor address _factory  address _WETH9  
factory
        factory = _factory;
factory
    function computeAddress address factory  PoolKey memory key internal pure returns  address pool  
factory
                        factory 
factory
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

factory
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
factory
    function verifyCallback address factory  PoolAddress PoolKey memory poolKey
        internal
        view
        returns  IUniswapV3Pool pool
     

factory
        pool = IUniswapV3Pool PoolAddress computeAddress factory  poolKey;
factory
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
factory
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
factory
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
factory
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

factory
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

factory
    address public immutable override factory;
factory
    constructor address _factory  address _WETH9  
factory
        factory = _factory;
factory
    function computeAddress address factory  PoolKey memory key internal pure returns  address pool  
factory
                        factory 
factory
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

factory
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
factory
    function verifyCallback address factory  PoolAddress PoolKey memory poolKey
        internal
        view
        returns  IUniswapV3Pool pool
     

factory
        pool = IUniswapV3Pool PoolAddress computeAddress factory  poolKey;
factory
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
factory
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
factory
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
factory
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

tokenA
        tokenA = path toAddress 0;
tokenA
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

tokenA
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
tokenA
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
tokenA
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

tokenA
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenA
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

tokenA
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenA
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

tokenB
        tokenB = path toAddress NEXT_OFFSET;
tokenB
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

tokenB
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
tokenB
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
tokenB
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

tokenB
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenB
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

tokenB
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenB
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

factory
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

factory
    address public immutable override factory;
factory
    constructor address _factory  address _WETH9  
factory
        factory = _factory;
factory
    function computeAddress address factory  PoolKey memory key internal pure returns  address pool  
factory
                        factory 
factory
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

factory
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
factory
    function verifyCallback address factory  PoolAddress PoolKey memory poolKey
        internal
        view
        returns  IUniswapV3Pool pool
     

factory
        pool = IUniswapV3Pool PoolAddress computeAddress factory  poolKey;
factory
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
factory
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
factory
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
factory
    constructor address _factory  address _WETH9  
_factory
        factory = _factory;
_factory
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
_factory
    constructor address _factory  address _WETH9  
_WETH9
        WETH9 = _WETH9;
_WETH9
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
_WETH9
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

factory
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

factory
    address public immutable override factory;
factory
    constructor address _factory  address _WETH9  
factory
        factory = _factory;
factory
    function computeAddress address factory  PoolKey memory key internal pure returns  address pool  
factory
                        factory 
factory
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

factory
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
factory
    function verifyCallback address factory  PoolAddress PoolKey memory poolKey
        internal
        view
        returns  IUniswapV3Pool pool
     

factory
        pool = IUniswapV3Pool PoolAddress computeAddress factory  poolKey;
factory
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
factory
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
factory
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
factory
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

tokenA
        tokenA = path toAddress 0;
tokenA
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

tokenA
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
tokenA
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
tokenA
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

tokenA
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenA
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

tokenA
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenA
    function decodeFirstPool bytes memory path
        internal
        pure
        returns  
            address tokenA 
            address tokenB 
            uint24 fee
        
     

tokenB
        tokenB = path toAddress NEXT_OFFSET;
tokenB
    function getPoolKey 
        address tokenA 
        address tokenB 
        uint24 fee
     internal pure returns  PoolKey memory  

tokenB
        if  tokenA > tokenB  tokenA  tokenB =  tokenB  tokenA;
tokenB
        return PoolKey  token0: tokenA  token1: tokenB  fee: fee;
tokenB
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

tokenB
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenB
    function getPool 
        address tokenA 
        address tokenB 
        uint24 fee
     private view returns  IUniswapV3Pool  

tokenB
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
tokenB
    function factory  external view returns  address;



    function token0  external view returns  address;



    function token1  external view returns  address;



    function fee  external view returns  uint24;






    function tickSpacing  external view returns  int24;





    function maxLiquidityPerTick  external view returns  uint128;





interface IUniswapV3PoolState  

factory
    function factory  external view returns  address;


    function WETH9  external view returns  address;




abstract contract PeripheryImmutableState is IPeripheryImmutableState  

factory
    address public immutable override factory;
factory
    constructor address _factory  address _WETH9  
factory
        factory = _factory;
factory
    function computeAddress address factory  PoolKey memory key internal pure returns  address pool  
factory
                        factory 
factory
    function verifyCallback 
        address factory 
        address tokenA 
        address tokenB 
        uint24 fee
     internal view returns  IUniswapV3Pool pool  

factory
        return verifyCallback factory  PoolAddress getPoolKey tokenA  tokenB  fee;
factory
    function verifyCallback address factory  PoolAddress PoolKey memory poolKey
        internal
        view
        returns  IUniswapV3Pool pool
     

factory
        pool = IUniswapV3Pool PoolAddress computeAddress factory  poolKey;
factory
    constructor address _factory  address _WETH9 PeripheryImmutableState _factory  _WETH9  
factory
        return IUniswapV3Pool PoolAddress computeAddress factory  PoolAddress getPoolKey tokenA  tokenB  fee;
factory
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
factory
        address tokenIn;
tokenIn
        address tokenIn;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
tokenIn
                ?  tokenIn < tokenOut  uint256 amount0Delta
tokenIn
                :  tokenOut < tokenIn  uint256 amount1Delta;
tokenIn
            pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
tokenIn
                pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
tokenIn
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
tokenIn
        address tokenOut;
tokenOut
        address tokenOut;
tokenOut
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenOut
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
tokenOut
                ?  tokenIn < tokenOut  uint256 amount0Delta
tokenOut
                :  tokenOut < tokenIn  uint256 amount1Delta;
tokenOut
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
tokenOut
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenOut
        bool zeroForOne = tokenIn < tokenOut;
tokenOut
            getPool tokenIn  tokenOut  fee swap 
tokenOut
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
tokenOut
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
tokenOut
        bool zeroForOne = tokenIn < tokenOut;
tokenOut
            getPool tokenIn  tokenOut  fee swap 
tokenOut
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
tokenOut
        address tokenIn;
tokenIn
        address tokenIn;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
tokenIn
                ?  tokenIn < tokenOut  uint256 amount0Delta
tokenIn
                :  tokenOut < tokenIn  uint256 amount1Delta;
tokenIn
            pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
tokenIn
                pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
tokenIn
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
tokenIn
        address tokenOut;
tokenOut
        address tokenOut;
tokenOut
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenOut
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
tokenOut
                ?  tokenIn < tokenOut  uint256 amount0Delta
tokenOut
                :  tokenOut < tokenIn  uint256 amount1Delta;
tokenOut
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
tokenOut
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenOut
        bool zeroForOne = tokenIn < tokenOut;
tokenOut
            getPool tokenIn  tokenOut  fee swap 
tokenOut
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
tokenOut
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
tokenOut
        bool zeroForOne = tokenIn < tokenOut;
tokenOut
            getPool tokenIn  tokenOut  fee swap 
tokenOut
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
tokenOut
        address tokenOut;
tokenOut
        address tokenOut;
tokenOut
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenOut
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
tokenOut
                ?  tokenIn < tokenOut  uint256 amount0Delta
tokenOut
                :  tokenOut < tokenIn  uint256 amount1Delta;
tokenOut
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
tokenOut
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenOut
        bool zeroForOne = tokenIn < tokenOut;
tokenOut
            getPool tokenIn  tokenOut  fee swap 
tokenOut
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
tokenOut
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
tokenOut
        bool zeroForOne = tokenIn < tokenOut;
tokenOut
            getPool tokenIn  tokenOut  fee swap 
tokenOut
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
tokenOut
        address tokenIn;
tokenIn
        address tokenIn;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
tokenIn
                ?  tokenIn < tokenOut  uint256 amount0Delta
tokenIn
                :  tokenOut < tokenIn  uint256 amount1Delta;
tokenIn
            pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
tokenIn
                pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
tokenIn
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
tokenIn
        address tokenIn;
tokenIn
        address tokenIn;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
tokenIn
                ?  tokenIn < tokenOut  uint256 amount0Delta
tokenIn
                :  tokenOut < tokenIn  uint256 amount1Delta;
tokenIn
            pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
tokenIn
                pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
tokenIn
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
tokenIn
        address tokenIn;
tokenIn
        address tokenIn;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
tokenIn
                ?  tokenIn < tokenOut  uint256 amount0Delta
tokenIn
                :  tokenOut < tokenIn  uint256 amount1Delta;
tokenIn
            pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
tokenIn
                pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
tokenIn
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
tokenIn
        address tokenOut;
tokenOut
        address tokenOut;
tokenOut
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenOut
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
tokenOut
                ?  tokenIn < tokenOut  uint256 amount0Delta
tokenOut
                :  tokenOut < tokenIn  uint256 amount1Delta;
tokenOut
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
tokenOut
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenOut
        bool zeroForOne = tokenIn < tokenOut;
tokenOut
            getPool tokenIn  tokenOut  fee swap 
tokenOut
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
tokenOut
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
tokenOut
        bool zeroForOne = tokenIn < tokenOut;
tokenOut
            getPool tokenIn  tokenOut  fee swap 
tokenOut
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
tokenOut
        address tokenIn;
tokenIn
        address tokenIn;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
tokenIn
                ?  tokenIn < tokenOut  uint256 amount0Delta
tokenIn
                :  tokenOut < tokenIn  uint256 amount1Delta;
tokenIn
            pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
tokenIn
                pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
tokenIn
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
tokenIn
    function initialize uint160 sqrtPriceX96 external;












    function mint 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount 
        bytes calldata data
     external returns  uint256 amount0  uint256 amount1;













    function collect 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;









    function burn 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount
     external returns  uint256 amount0  uint256 amount1;











    function swap 
        address recipient 
        bool zeroForOne 
        int256 amountSpecified 
        uint160 sqrtPriceLimitX96 
        bytes calldata data
     external returns  int256 amount0  int256 amount1;









    function flash 
        address recipient 
        uint256 amount0 
        uint256 amount1 
        bytes calldata data
     external;





    function increaseObservationCardinalityNext uint16 observationCardinalityNext external;




interface IUniswapV3PoolOwnerActions  

recipient
    function setFeeProtocol uint8 feeProtocol0  uint8 feeProtocol1 external;







    function collectProtocol 
        address recipient 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;





interface IUniswapV3PoolEvents  

recipient
        address recipient 
recipient
        address indexed recipient 
recipient
        address indexed recipient 
recipient
    event CollectProtocol address indexed sender  address indexed recipient  uint128 amount0  uint128 amount1;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

recipient
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
recipient
            TransferHelper safeTransferETH recipient  balanceWETH9;
recipient
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken;
recipient
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

recipient
            IWETH9 WETH9 transfer recipient  value;
recipient
            TransferHelper safeTransfer token  recipient  value;
recipient
            TransferHelper safeTransferFrom token  payer  recipient  value;
recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
recipient
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
recipient
    function exactInputInternal 
        uint256 amountIn 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountOut  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
                hasMultiplePools ? address this : params recipient     for intermediate swaps  this contract custodies
recipient
    function exactOutputInternal 
        uint256 amountOut 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountIn  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
            params recipient 
recipient
    function initialize uint160 sqrtPriceX96 external;












    function mint 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount 
        bytes calldata data
     external returns  uint256 amount0  uint256 amount1;













    function collect 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;









    function burn 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount
     external returns  uint256 amount0  uint256 amount1;











    function swap 
        address recipient 
        bool zeroForOne 
        int256 amountSpecified 
        uint160 sqrtPriceLimitX96 
        bytes calldata data
     external returns  int256 amount0  int256 amount1;









    function flash 
        address recipient 
        uint256 amount0 
        uint256 amount1 
        bytes calldata data
     external;





    function increaseObservationCardinalityNext uint16 observationCardinalityNext external;




interface IUniswapV3PoolOwnerActions  

recipient
    function setFeeProtocol uint8 feeProtocol0  uint8 feeProtocol1 external;







    function collectProtocol 
        address recipient 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;





interface IUniswapV3PoolEvents  

recipient
        address recipient 
recipient
        address indexed recipient 
recipient
        address indexed recipient 
recipient
    event CollectProtocol address indexed sender  address indexed recipient  uint128 amount0  uint128 amount1;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

recipient
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
recipient
            TransferHelper safeTransferETH recipient  balanceWETH9;
recipient
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken;
recipient
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

recipient
            IWETH9 WETH9 transfer recipient  value;
recipient
            TransferHelper safeTransfer token  recipient  value;
recipient
            TransferHelper safeTransferFrom token  payer  recipient  value;
recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
recipient
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
recipient
    function exactInputInternal 
        uint256 amountIn 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountOut  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
                hasMultiplePools ? address this : params recipient     for intermediate swaps  this contract custodies
recipient
    function exactOutputInternal 
        uint256 amountOut 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountIn  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
            params recipient 
recipient
        address tokenIn;
tokenIn
        address tokenIn;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
tokenIn
                ?  tokenIn < tokenOut  uint256 amount0Delta
tokenIn
                :  tokenOut < tokenIn  uint256 amount1Delta;
tokenIn
            pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
tokenIn
                pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
tokenIn
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
tokenIn
        address tokenOut;
tokenOut
        address tokenOut;
tokenOut
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenOut
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
tokenOut
                ?  tokenIn < tokenOut  uint256 amount0Delta
tokenOut
                :  tokenOut < tokenIn  uint256 amount1Delta;
tokenOut
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
tokenOut
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenOut
        bool zeroForOne = tokenIn < tokenOut;
tokenOut
            getPool tokenIn  tokenOut  fee swap 
tokenOut
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
tokenOut
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
tokenOut
        bool zeroForOne = tokenIn < tokenOut;
tokenOut
            getPool tokenIn  tokenOut  fee swap 
tokenOut
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
tokenOut
        address tokenIn;
tokenIn
        address tokenIn;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
tokenIn
                ?  tokenIn < tokenOut  uint256 amount0Delta
tokenIn
                :  tokenOut < tokenIn  uint256 amount1Delta;
tokenIn
            pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
tokenIn
                pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
tokenIn
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
tokenIn
        address tokenOut;
tokenOut
        address tokenOut;
tokenOut
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenOut
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
tokenOut
                ?  tokenIn < tokenOut  uint256 amount0Delta
tokenOut
                :  tokenOut < tokenIn  uint256 amount1Delta;
tokenOut
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
tokenOut
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenOut
        bool zeroForOne = tokenIn < tokenOut;
tokenOut
            getPool tokenIn  tokenOut  fee swap 
tokenOut
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
tokenOut
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
tokenOut
        bool zeroForOne = tokenIn < tokenOut;
tokenOut
            getPool tokenIn  tokenOut  fee swap 
tokenOut
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
tokenOut
    function initialize uint160 sqrtPriceX96 external;












    function mint 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount 
        bytes calldata data
     external returns  uint256 amount0  uint256 amount1;













    function collect 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;









    function burn 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount
     external returns  uint256 amount0  uint256 amount1;











    function swap 
        address recipient 
        bool zeroForOne 
        int256 amountSpecified 
        uint160 sqrtPriceLimitX96 
        bytes calldata data
     external returns  int256 amount0  int256 amount1;









    function flash 
        address recipient 
        uint256 amount0 
        uint256 amount1 
        bytes calldata data
     external;





    function increaseObservationCardinalityNext uint16 observationCardinalityNext external;




interface IUniswapV3PoolOwnerActions  

recipient
    function setFeeProtocol uint8 feeProtocol0  uint8 feeProtocol1 external;







    function collectProtocol 
        address recipient 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;





interface IUniswapV3PoolEvents  

recipient
        address recipient 
recipient
        address indexed recipient 
recipient
        address indexed recipient 
recipient
    event CollectProtocol address indexed sender  address indexed recipient  uint128 amount0  uint128 amount1;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

recipient
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
recipient
            TransferHelper safeTransferETH recipient  balanceWETH9;
recipient
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken;
recipient
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

recipient
            IWETH9 WETH9 transfer recipient  value;
recipient
            TransferHelper safeTransfer token  recipient  value;
recipient
            TransferHelper safeTransferFrom token  payer  recipient  value;
recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
recipient
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
recipient
    function exactInputInternal 
        uint256 amountIn 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountOut  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
                hasMultiplePools ? address this : params recipient     for intermediate swaps  this contract custodies
recipient
    function exactOutputInternal 
        uint256 amountOut 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountIn  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
            params recipient 
recipient
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

payer
         else if  payer == address this  
payer
            TransferHelper safeTransferFrom token  payer  recipient  value;
payer
        address payer;
payer
            pay tokenIn  data payer  msg sender  amountToPay;
payer
                pay tokenIn  data payer  msg sender  amountToPay;
payer
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
payer
        address payer = msg sender;    msg sender pays for the first hop
payer
                    payer: payer
payer
                payer = address this;    at this point  the caller has paid
payer
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
payer
            SwapCallbackData  path: params path  payer: msg sender
payer
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

payer
         else if  payer == address this  
payer
            TransferHelper safeTransferFrom token  payer  recipient  value;
payer
        address payer;
payer
            pay tokenIn  data payer  msg sender  amountToPay;
payer
                pay tokenIn  data payer  msg sender  amountToPay;
payer
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
payer
        address payer = msg sender;    msg sender pays for the first hop
payer
                    payer: payer
payer
                payer = address this;    at this point  the caller has paid
payer
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
payer
            SwapCallbackData  path: params path  payer: msg sender
payer
    function initialize uint160 sqrtPriceX96 external;












    function mint 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount 
        bytes calldata data
     external returns  uint256 amount0  uint256 amount1;













    function collect 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;









    function burn 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount
     external returns  uint256 amount0  uint256 amount1;











    function swap 
        address recipient 
        bool zeroForOne 
        int256 amountSpecified 
        uint160 sqrtPriceLimitX96 
        bytes calldata data
     external returns  int256 amount0  int256 amount1;









    function flash 
        address recipient 
        uint256 amount0 
        uint256 amount1 
        bytes calldata data
     external;





    function increaseObservationCardinalityNext uint16 observationCardinalityNext external;




interface IUniswapV3PoolOwnerActions  

recipient
    function setFeeProtocol uint8 feeProtocol0  uint8 feeProtocol1 external;







    function collectProtocol 
        address recipient 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;





interface IUniswapV3PoolEvents  

recipient
        address recipient 
recipient
        address indexed recipient 
recipient
        address indexed recipient 
recipient
    event CollectProtocol address indexed sender  address indexed recipient  uint128 amount0  uint128 amount1;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

recipient
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
recipient
            TransferHelper safeTransferETH recipient  balanceWETH9;
recipient
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken;
recipient
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

recipient
            IWETH9 WETH9 transfer recipient  value;
recipient
            TransferHelper safeTransfer token  recipient  value;
recipient
            TransferHelper safeTransferFrom token  payer  recipient  value;
recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
recipient
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
recipient
    function exactInputInternal 
        uint256 amountIn 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountOut  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
                hasMultiplePools ? address this : params recipient     for intermediate swaps  this contract custodies
recipient
    function exactOutputInternal 
        uint256 amountOut 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountIn  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
            params recipient 
recipient
    function initialize uint160 sqrtPriceX96 external;












    function mint 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount 
        bytes calldata data
     external returns  uint256 amount0  uint256 amount1;













    function collect 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;









    function burn 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount
     external returns  uint256 amount0  uint256 amount1;











    function swap 
        address recipient 
        bool zeroForOne 
        int256 amountSpecified 
        uint160 sqrtPriceLimitX96 
        bytes calldata data
     external returns  int256 amount0  int256 amount1;









    function flash 
        address recipient 
        uint256 amount0 
        uint256 amount1 
        bytes calldata data
     external;





    function increaseObservationCardinalityNext uint16 observationCardinalityNext external;




interface IUniswapV3PoolOwnerActions  

recipient
    function setFeeProtocol uint8 feeProtocol0  uint8 feeProtocol1 external;







    function collectProtocol 
        address recipient 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;





interface IUniswapV3PoolEvents  

recipient
        address recipient 
recipient
        address indexed recipient 
recipient
        address indexed recipient 
recipient
    event CollectProtocol address indexed sender  address indexed recipient  uint128 amount0  uint128 amount1;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

recipient
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
recipient
            TransferHelper safeTransferETH recipient  balanceWETH9;
recipient
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken;
recipient
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

recipient
            IWETH9 WETH9 transfer recipient  value;
recipient
            TransferHelper safeTransfer token  recipient  value;
recipient
            TransferHelper safeTransferFrom token  payer  recipient  value;
recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
recipient
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
recipient
    function exactInputInternal 
        uint256 amountIn 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountOut  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
                hasMultiplePools ? address this : params recipient     for intermediate swaps  this contract custodies
recipient
    function exactOutputInternal 
        uint256 amountOut 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountIn  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
            params recipient 
recipient
        address tokenIn;
tokenIn
        address tokenIn;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
tokenIn
                ?  tokenIn < tokenOut  uint256 amount0Delta
tokenIn
                :  tokenOut < tokenIn  uint256 amount1Delta;
tokenIn
            pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
tokenIn
                pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
tokenIn
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
tokenIn
        address tokenOut;
tokenOut
        address tokenOut;
tokenOut
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenOut
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
tokenOut
                ?  tokenIn < tokenOut  uint256 amount0Delta
tokenOut
                :  tokenOut < tokenIn  uint256 amount1Delta;
tokenOut
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
tokenOut
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenOut
        bool zeroForOne = tokenIn < tokenOut;
tokenOut
            getPool tokenIn  tokenOut  fee swap 
tokenOut
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
tokenOut
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
tokenOut
        bool zeroForOne = tokenIn < tokenOut;
tokenOut
            getPool tokenIn  tokenOut  fee swap 
tokenOut
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
tokenOut
        address tokenIn;
tokenIn
        address tokenIn;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
tokenIn
                ?  tokenIn < tokenOut  uint256 amount0Delta
tokenIn
                :  tokenOut < tokenIn  uint256 amount1Delta;
tokenIn
            pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
tokenIn
                pay tokenIn  data payer  msg sender  amountToPay;
tokenIn
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
tokenIn
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
tokenIn
        bool zeroForOne = tokenIn < tokenOut;
tokenIn
            getPool tokenIn  tokenOut  fee swap 
tokenIn
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
tokenIn
        address tokenOut;
tokenOut
        address tokenOut;
tokenOut
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenOut
        CallbackValidation verifyCallback factory  tokenIn  tokenOut  fee;
tokenOut
                ?  tokenIn < tokenOut  uint256 amount0Delta
tokenOut
                :  tokenOut < tokenIn  uint256 amount1Delta;
tokenOut
                tokenIn = tokenOut;    swap in out because exact output swaps are reversed
tokenOut
         address tokenIn  address tokenOut  uint24 fee = data path decodeFirstPool ;
tokenOut
        bool zeroForOne = tokenIn < tokenOut;
tokenOut
            getPool tokenIn  tokenOut  fee swap 
tokenOut
            SwapCallbackData  path: abi encodePacked params tokenIn  params fee  params tokenOut  payer: msg sender
tokenOut
         address tokenOut  address tokenIn  uint24 fee = data path decodeFirstPool ;
tokenOut
        bool zeroForOne = tokenIn < tokenOut;
tokenOut
            getPool tokenIn  tokenOut  fee swap 
tokenOut
            SwapCallbackData  path: abi encodePacked params tokenOut  params fee  params tokenIn  payer: msg sender
tokenOut
    function initialize uint160 sqrtPriceX96 external;












    function mint 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount 
        bytes calldata data
     external returns  uint256 amount0  uint256 amount1;













    function collect 
        address recipient 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;









    function burn 
        int24 tickLower 
        int24 tickUpper 
        uint128 amount
     external returns  uint256 amount0  uint256 amount1;











    function swap 
        address recipient 
        bool zeroForOne 
        int256 amountSpecified 
        uint160 sqrtPriceLimitX96 
        bytes calldata data
     external returns  int256 amount0  int256 amount1;









    function flash 
        address recipient 
        uint256 amount0 
        uint256 amount1 
        bytes calldata data
     external;





    function increaseObservationCardinalityNext uint16 observationCardinalityNext external;




interface IUniswapV3PoolOwnerActions  

recipient
    function setFeeProtocol uint8 feeProtocol0  uint8 feeProtocol1 external;







    function collectProtocol 
        address recipient 
        uint128 amount0Requested 
        uint128 amount1Requested
     external returns  uint128 amount0  uint128 amount1;





interface IUniswapV3PoolEvents  

recipient
        address recipient 
recipient
        address indexed recipient 
recipient
        address indexed recipient 
recipient
    event CollectProtocol address indexed sender  address indexed recipient  uint128 amount0  uint128 amount1;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
        address recipient;
recipient
    function totalSupply  external view returns  uint256;

       
       @dev Returns the amount of tokens owned by `account` 
       
    function balanceOf address account external view returns  uint256;

       
       @dev Moves `amount` tokens from the caller's account to `recipient` 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transfer address recipient  uint256 amount external returns  bool;

       
       @dev Returns the remaining number of tokens that `spender` will be
       allowed to spend on behalf of `owner` through  transferFrom  This is

recipient
    function approve address spender  uint256 amount external returns  bool;

       
       @dev Moves `amount` tokens from `sender` to `recipient` using the
       allowance mechanism  `amount` is then deducted from the caller's
       allowance 
      
       Returns a boolean value indicating whether the operation succeeded 
      
       Emits a  Transfer event 

recipient
    function transferFrom 
        address sender 
        address recipient 
        uint256 amount
     external returns  bool;

       
       @dev Emitted when `value` tokens are moved from one account  `from` to
       another  `to` 
      
       Note that `value` may be zero 
       
    event Transfer address indexed from  address indexed to  uint256 value;

       
       @dev Emitted when the allowance of a `spender` for an `owner` is set by
       a call to  approve  `value` is the new allowance 

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable;




    function refundETH  external payable;






    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable;




interface IWETH9 is IERC20  

recipient
    function unwrapWETH9 uint256 amountMinimum  address recipient external payable override  
recipient
            TransferHelper safeTransferETH recipient  balanceWETH9;
recipient
    function sweepToken 
        address token 
        uint256 amountMinimum 
        address recipient
     external payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken;
recipient
    function pay 
        address token 
        address payer 
        address recipient 
        uint256 value
     internal  

recipient
            IWETH9 WETH9 transfer recipient  value;
recipient
            TransferHelper safeTransfer token  recipient  value;
recipient
            TransferHelper safeTransferFrom token  payer  recipient  value;
recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;




    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     external payable;



abstract contract PeripheryPaymentsWithFee is PeripheryPayments  IPeripheryPaymentsWithFee  

recipient
    function unwrapWETH9WithFee 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransferETH recipient  balanceWETH9 - feeAmount;
recipient
    function sweepTokenWithFee 
        address token 
        uint256 amountMinimum 
        address recipient 
        uint256 feeBips 
        address feeRecipient
     public payable override  

recipient
            TransferHelper safeTransfer token  recipient  balanceToken - feeAmount;
recipient
    function exactInputInternal 
        uint256 amountIn 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountOut  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
                hasMultiplePools ? address this : params recipient     for intermediate swaps  this contract custodies
recipient
    function exactOutputInternal 
        uint256 amountOut 
        address recipient 
        uint160 sqrtPriceLimitX96 
        SwapCallbackData memory data
     private returns  uint256 amountIn  

recipient
        if  recipient == address 0 recipient = address this;
recipient
                recipient 
recipient
            params recipient 
recipient
            params recipient 
recipient
